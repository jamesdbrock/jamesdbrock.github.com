<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>High Frequency FIX Parser: High Frequency FIX — C++ Library for Financial Information Exchange Protocol</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<style type="text/css">
h1 { margin-top:5em; }
p li { text-align:justify; }
h1, h2, h3, h4, h5, h6, p, li { max-width: 900px; }
code {font-weight:bold;}
</style>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">High Frequency FIX Parser
   </div>
   <div id="projectbrief">C++ library for high frequency messaging with the Financial Information Exchange (FIX) protocol.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">High Frequency FIX — C++ Library for Financial Information Exchange Protocol </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="mainpage"></a></p>
<h1>Introduction</h1>
<p>The High Frequency FIX Parser library is an open source implementation of <a href="https://www.fixtrading.org/standards/">tagvalue FIX (classic FIX)</a> intended for use by developers of high frequency, low latency financial software. The purpose of the library is to do fast, efficient encoding and decoding of FIX in place, at the location of the I/O buffer. The library does not use intermediate message objects, and it does <b>no memory allocation</b> on the free store (the “heap”).</p>
<p><em>hffix</em> library is not certified by any industry-leading committees. It is not an “engine.” It is not an “adaptor.” It has no threading, no I/O, no object-oriented subtyping. It is just a superfast parser and serializer in plain modern generic-iterator-style C++98.</p>
<h1>Hello, FIX! Quick Start</h1>
<p>The main repository is at <a href="https://github.com/jamesdbrock/hffix">https://github.com/jamesdbrock/hffix</a></p>
<h2>fixprint</h2>
<p>To see an example of the library in action, enter these four commands at your shell prompt. This example uses the <code>fixprint</code> utility which comes with the <em>hffix</em> library. The result will be a colorized and pretty-printed FIX 5.0 test data set. </p><pre class="fragment">git clone https://github.com/jamesdbrock/hffix.git
cd hffix
make fixprint
util/bin/fixprint --color &lt; test/data/fix.5.0.set.2 | less -R
</pre><h2>Usage</h2>
<p>The library is header-only, so there is nothing to link. To use the <code><a class="el" href="hffix_8hpp.html" title="The High Frequency FIX Parser Library. Repository at http://github.com/jamesdbrock/hffix.">hffix.hpp</a></code> library for C++ FIX development, place the two header files in your include path and <code>#include &lt;<a class="el" href="hffix_8hpp.html" title="The High Frequency FIX Parser Library. Repository at http://github.com/jamesdbrock/hffix.">hffix.hpp</a>&gt;</code>.</p>
<ul>
<li><code><a class="el" href="hffix_8hpp.html" title="The High Frequency FIX Parser Library. Repository at http://github.com/jamesdbrock/hffix.">hffix/include/hffix.hpp</a></code></li>
<li><code><a class="el" href="hffix__fields_8hpp.html" title="The hffix_fields.hpp file is generated by the fixspec/spec-parse-fields Haskell program from the FIX ...">hffix/include/hffix_fields.hpp</a></code></li>
</ul>
<h2>Documentation</h2>
<p>Full Doxygen is on the internet at <a href="https://jamesdbrock.github.io/hffix">https://jamesdbrock.github.io/hffix</a></p>
<p>To build the Doxygen html documentation in the <code>doc/html</code> directory and view it: </p><pre class="fragment">git clone https://github.com/jamesdbrock/hffix.git
cd hffix
make doc
xdg-open doc/html/index.html
</pre> <h1>Library Design</h1>
<p>High Frequency FIX Parser tries to follow the <a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md">C++ Core Guidelines</a> and the <a href="http://www.boost.org/development/requirements.html">Boost Library Requirements and Guidelines</a>. It is modern platform-independent header-only C++98 and depends only on the C++ Standard Library. It is patterned after the C++ Standard Template Library, and it models each FIX message with Container and Iterator concepts. It employs compile-time generic templates but does not employ object-oriented inheritance.</p>
<h2>Speed</h2>
<p>The design criteria for High Frequency FIX Parser are based on our experience passing messages to various FIX hosts for high frequency quantitative trading at <a href="http://www.t3live.com">T3 Trading Group, LLC</a>. These design criteria follow from the observation that the latency of a trading system depends on the following list of considerations, in descending order of importance.</p>
<ol type="1">
<li><b>Network architecture.</b> Most of the latency will be in the network between us and our peer, outside of our control. We should do everything we can to exert some control over the network to shorten our path.</li>
<li><b>Operating System I/O syscall usage.</b> We should be very careful about which syscalls we're using to do network I/O. Perhaps use an OS bypass NIC.</li>
<li><b>Operating System thread usage.</b> We should be running a single pinned operating system thread per core with a multiplexed event loop like <em>Boost Asio</em> or <em>libuv</em> for waiting on I/O events.</li>
<li><b>Userspace runtime memory usage.</b> Memory allocations can trigger a page fault and a syscall. Complicated object-oriented designs with lots of pointer indirections lead to cache misses and branch prediction failures.</li>
<li><b>Userspace algorithms.</b> This is the easiest stuff to measure and the most fun to discuss, so a lot of attention is focused here, but it's only important if we get all the other considerations right first.</li>
</ol>
<p>The <em>hffix</em> library assumes that the library user will want to make their own choices about considerations <b>2</b> and <b>3</b>, and the <em>hffix</em> library focuses on providing good answers for consideration <b>4</b>. It does this by using only stack memory and I/O buffer memory, and never allocating on the free store.</p>
<p>In contrast, the popular alternative <em>QuickFix</em> library forces the user to use the <em>QuickFix</em> solution to considerations <b>2</b> and <b>3</b> for threads and sockets, and most of <em>QuickFix</em>'s choices about threads and sockets are not great. <em>QuickFix</em> also has an inefficient object-oriented design for consideration <b>4</b>.</p>
<p>See also <a href="https://www.youtube.com/watch?v=NH1Tta7purM">CppCon 2017: Carl Cook “When a Microsecond Is an Eternity: High Performance Trading Systems in C++”</a></p>
<h2>Specs Included</h2>
<p>All of the Financial Information Exchange (FIX) protocol specification versions supported by the library are bundled into the the distribution, in the <code>fixspec</code> directory. As a convenience for the developer, the High Frequency FIX Parser library includes a program which parses the FIX protocol specification documents and generates the <code><a class="el" href="hffix__fields_8hpp.html" title="The hffix_fields.hpp file is generated by the fixspec/spec-parse-fields Haskell program from the FIX ...">include/hffix_fields.hpp</a></code> file. That file <code><a class="el" href="namespacehffix_1_1tag.html" title="Namespace for all field tag name enums.">hffix::tag</a></code> enums and an <code><a class="el" href="namespacehffix.html#a7a9146dc05a357c892cb03ee878463aa" title="Populate an AssociativeContainer with the names of all the FIX fields.">hffix::dictionary_init_field</a></code> function which allows fields to be referred to by name instead of number during both compile-time and run-time.</p>
<h2>Platforms</h2>
<p>The library is platform-independent C++98, and is tested on Linux with <em>gcc</em> and <em>clang</em> on <a href="https://github.com/jamesdbrock/hffix/actions/workflows/ci.yml">Github Actions</a>.</p>
<h2>License</h2>
<p>The main High Frequency FIX Parser Library is distributed under the open source FreeBSD License, also known as the Simplified BSD License.</p>
<p>Some extra components are under the Boost Software License.</p>
<p>Included FIX specs are copyright FIX Protocol, Limited.</p>
<h1>Features</h1>
<h2>Serial Message Field Access</h2>
<p>For reading FIX messages, High Frequency FIX Parser presents an STL-style <a href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator">immutable Forward Iterator</a> interface. Writing fields is done serially with an interface similar to an STL-style <a href="https://en.cppreference.com/w/cpp/named_req/SequenceContainer">Back Insertion Sequence Container</a>. Reading and writing are done directly on the I/O buffer, without any intermediate objects.</p>
<p>The disadvantage of this implementation is that the message API provides serial access to fields, not random access. Of course, when we're writing a message, random access isn't important, just write out the fields in order. When we're reading a message, it's easy enough to pretend that we have random access by using iterator algorithms like <code>std::find</code>. A convenience algorithm <code><a class="el" href="classhffix_1_1message__reader.html#a586e2203e9b93c9c9c740deb3548d177" title="Convenient synonym for hffix::find_with_hint(reader.begin(), reader.end(), hffix::tag_equal(tag),...">hffix::message_reader::find_with_hint</a></code> is provided by this library for efficiently reading fields when you know approximately what field order to expect. See the examples below for how this works out in practice.</p>
<p>The advantage is that this enables the High Frequency FIX Parser library to completely avoid free store memory allocation. The library performs all memory allocation on the stack, and the library never requires developers using the library to allocate anything on the free store with <code>new</code> or <code>malloc</code>.</p>
<p>Field values in the FIX protocol are always encoded on the wire as ASCII, and High Frequency FIX Parser exposes field values to the developer as iterator range <code>char const* begin(), char const* end()</code>. High Frequency FIX Parser also provides a complete set of conversion functions to native C++ types for <em>ints</em>, <em>decimal floats</em>, <em>dates</em> and <em>times</em>, et cetera — see documentation for <code><a class="el" href="classhffix_1_1message__writer.html" title="One FIX message for writing.">hffix::message_writer</a></code> and <code><a class="el" href="classhffix_1_1field__value.html" title="FIX field value for hffix::message_reader.">hffix::field_value</a></code>.</p>
<h2>Exceptions</h2>
<p>Some functions in this library may throw <code>std::logic_error</code> if a precondition is not met by the programmer, so you can usually prevent the library from throwing exceptions by meeting the precondition. All methods, functions, constructors, and destructors provide the No-Throw exception guarantee unless they are documented to throw exceptions, in which case they provide the Basic exception guarantee. See documentation for details.</p>
<h2>Thread Safety</h2>
<p>High Frequency FIX Parser is not thread-aware at all and has no threads, mutexes, locks, or atomic operations.</p>
<p>All <code>const</code> methods of the <code><a class="el" href="classhffix_1_1message__reader.html" title="One FIX message for reading.">hffix::message_reader</a></code> are safe for concurrent calls.</p>
<p>The <code><a class="el" href="classhffix_1_1message__writer.html" title="One FIX message for writing.">hffix::message_writer</a></code> is not safe for concurrent calls.</p>
<p><code><a class="el" href="classhffix_1_1message__reader.html" title="One FIX message for reading.">hffix::message_reader</a></code> and <code><a class="el" href="classhffix_1_1message__writer.html" title="One FIX message for writing.">hffix::message_writer</a></code> have no storage of their own, they read and write fields directly on an I/O buffer. The developer must guarantee that the buffer endures while fields are being read or written.</p>
<h2>FIX Sessions</h2>
<p>Managing sessions requires making choices about sockets and threads. High Frequency FIX Parser does not manage sessions. It is intended for developers who want a FIX parser with which to build a session manager for a high-performance trading system that already has a socket and threading architecture.</p>
<p>FIX has transport-layer features mixed in with the messages, and most FIX hosts have various quirks in the way they employ the administrative messages. To manage a FIX session your application will need to match the the transport-layer and administrative features of the other FIX host. High Frequency FIX Parser has the flexibility to express any subset or proprietary superset of FIX.</p>
<p>See also <a href="http://www.fixtradingcommunity.org/pg/file/fplpo/read/30489/fix-sessionlevel-test-cases-and-expected-behaviors">FIX Session-level Test Cases and Expected Behaviors</a></p>
<h2>Numerics</h2>
<p>No native floating-point numeric types (<code>double</code>, <code>float</code>) are employed by the library. ASCII-encoded decimal numbers are represented by integral mantissa and exponent. See <code><a class="el" href="classhffix_1_1message__writer.html#adc62f5b1fd0193b999d1ddf84ebf4cf1" title="Append a decimal float field to the message.">hffix::message_writer::push_back_decimal()</a></code> and <code><a class="el" href="classhffix_1_1field__value.html#a9ab721a634c9842c171591a8fec9488d" title="Ascii-to-decimal conversion.">hffix::field_value::as_decimal()</a></code>. As with every FIX data type, the High Frequency FIX library user has the option to serialize and deserialize numeric fields themself rather than use these methods.</p>
<h2>Encryption</h2>
<p>High Frequency FIX Parser supports the binary data field types such as <em>SecureData</em>, but it does not implement any of the <em>EncryptMethods</em> suggested by the FIX specifications. If you want to encrypt or decrypt some data you'll have to do the encryption or decryption yourself.</p>
<h2>CheckSum</h2>
<p>High Frequency FIX Parser will calculate the <em>CheckSum</em> field for all messages that you encode. It can validate the <em>CheckSum</em> of messages decoded, but does not do that calculation unless you explicitly ask for it.</p>
<h2>Sequence Numbers</h2>
<p>The <em>MsgSeqNum</em> field in the FIX Standard Header is exposed for reading and writing.</p>
<h2>Administrative Messages</h2>
<p>The administrative messages <em>Logon</em>, <em>Logout</em>, <em>ResendRequest</em>, <em>Heartbeat</em>, <em>TestRequest</em>, <em>SeqReset-Reset</em> and <em>SeqReset-GapFill</em> don't get special treatment in High Frequency FIX Parser. Any administrative message can be encoded or decoded like any other message.</p>
<h2>User-Defined Fields and Custom Tags</h2>
<p>High Frequency FIX Parser does not enforce the data type of the Field Definitions for content fields in the FIX spec, so the developer is free to read or write any tag number with any field data type. See <code><a class="el" href="classhffix_1_1message__writer.html" title="One FIX message for writing.">hffix::message_writer</a></code> and <code><a class="el" href="classhffix_1_1field__value.html" title="FIX field value for hffix::message_reader.">hffix::field_value</a></code> documentation under Extension for details.</p>
<h1>Using High Frequency FIX Parser</h1>
<h2>Writing a Message Example</h2>
<p>This example program is in the <em>hffix</em> repository at <code>test/src/writer01.cpp</code>.</p>
<p>It writes a <em>Logon</em> message and a <em>New Order - Single</em> message to <code>stdout</code>.</p>
<div class="fragment"><div class="line"><span class="comment">// We want Boost Date_Time support, so include these before hffix.hpp.</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/date_time/posix_time/posix_time_types.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/date_time/gregorian/gregorian_types.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="hffix_8hpp.html">hffix.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>boost::posix_time;</div>
<div class="line"><span class="keyword">using namespace </span>boost::gregorian;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> seq_send(1); <span class="comment">// Sending sequence number.</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">char</span> buffer[1 &lt;&lt; 13];</div>
<div class="line"> </div>
<div class="line">    ptime tsend(date(2017,8,9), time_duration(12,34,56));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// We&#39;ll put a FIX Logon message in the buffer.</span></div>
<div class="line">    <a class="code hl_class" href="classhffix_1_1message__writer.html">hffix::message_writer</a> logon(buffer, buffer + <span class="keyword">sizeof</span>(buffer));</div>
<div class="line"> </div>
<div class="line">    logon.push_back_header(<span class="stringliteral">&quot;FIX.4.2&quot;</span>); <span class="comment">// Write BeginString and BodyLength.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Logon MsgType.</span></div>
<div class="line">    logon.push_back_string    (<a class="code hl_enumvalue" href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487baf0f67608ee9620fe6cd6ebeba4033922">hffix::tag::MsgType</a>, <span class="stringliteral">&quot;A&quot;</span>);</div>
<div class="line">    logon.push_back_string    (<a class="code hl_enumvalue" href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487baa745e1759f1ef78abff6585521b21159">hffix::tag::SenderCompID</a>, <span class="stringliteral">&quot;AAAA&quot;</span>);</div>
<div class="line">    logon.push_back_string    (<a class="code hl_enumvalue" href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487baaf9503fa60ec34d2bafd7444eff6c42c">hffix::tag::TargetCompID</a>, <span class="stringliteral">&quot;BBBB&quot;</span>);</div>
<div class="line">    logon.push_back_int       (<a class="code hl_enumvalue" href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487bab32e2b61a6da369187ba759ef12e1fa3">hffix::tag::MsgSeqNum</a>, seq_send++);</div>
<div class="line">    logon.push_back_timestamp (<a class="code hl_enumvalue" href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487ba90e2170482ce314ceef2d58ccc6d0638">hffix::tag::SendingTime</a>, tsend);</div>
<div class="line">    <span class="comment">// No encryption.</span></div>
<div class="line">    logon.push_back_int       (<a class="code hl_enumvalue" href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487baaefd2f2a07aa3496587f459d8a3d024b">hffix::tag::EncryptMethod</a>, 0);</div>
<div class="line">    <span class="comment">// 10 second heartbeat interval.</span></div>
<div class="line">    logon.push_back_int       (<a class="code hl_enumvalue" href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487ba1c04775c30e6fc84f399536e376e17db">hffix::tag::HeartBtInt</a>, 10);</div>
<div class="line"> </div>
<div class="line">    logon.push_back_trailer(); <span class="comment">// write CheckSum.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Now the Logon message is written to the buffer.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Add a FIX New Order - Single message to the buffer, after the Logon</span></div>
<div class="line">    <span class="comment">// message.</span></div>
<div class="line">    <a class="code hl_class" href="classhffix_1_1message__writer.html">hffix::message_writer</a> new_order(logon.message_end(), buffer + <span class="keyword">sizeof</span>(buffer));</div>
<div class="line"> </div>
<div class="line">    new_order.push_back_header(<span class="stringliteral">&quot;FIX.4.2&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// New Order - Single</span></div>
<div class="line">    new_order.push_back_string    (<a class="code hl_enumvalue" href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487baf0f67608ee9620fe6cd6ebeba4033922">hffix::tag::MsgType</a>, <span class="stringliteral">&quot;D&quot;</span>);</div>
<div class="line">    <span class="comment">// Required Standard Header field.</span></div>
<div class="line">    new_order.push_back_string    (<a class="code hl_enumvalue" href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487baa745e1759f1ef78abff6585521b21159">hffix::tag::SenderCompID</a>, <span class="stringliteral">&quot;AAAA&quot;</span>);</div>
<div class="line">    new_order.push_back_string    (<a class="code hl_enumvalue" href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487baaf9503fa60ec34d2bafd7444eff6c42c">hffix::tag::TargetCompID</a>, <span class="stringliteral">&quot;BBBB&quot;</span>);</div>
<div class="line">    new_order.push_back_int       (<a class="code hl_enumvalue" href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487bab32e2b61a6da369187ba759ef12e1fa3">hffix::tag::MsgSeqNum</a>, seq_send++);</div>
<div class="line">    new_order.push_back_timestamp (<a class="code hl_enumvalue" href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487ba90e2170482ce314ceef2d58ccc6d0638">hffix::tag::SendingTime</a>, tsend);</div>
<div class="line">    new_order.push_back_string    (<a class="code hl_enumvalue" href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487ba873332fa303a3d02d2201337806aede7">hffix::tag::ClOrdID</a>, <span class="stringliteral">&quot;A1&quot;</span>);</div>
<div class="line">    <span class="comment">// Automated execution.</span></div>
<div class="line">    new_order.push_back_char      (<a class="code hl_enumvalue" href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487ba0cd1257dc61dfa06ed979993350a727c">hffix::tag::HandlInst</a>, <span class="charliteral">&#39;1&#39;</span>);</div>
<div class="line">    <span class="comment">// Ticker symbol OIH.</span></div>
<div class="line">    new_order.push_back_string    (<a class="code hl_enumvalue" href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487ba4077088f5a179648e4bf53281329b932">hffix::tag::Symbol</a>, <span class="stringliteral">&quot;OIH&quot;</span>);</div>
<div class="line">    <span class="comment">// Buy side.</span></div>
<div class="line">    new_order.push_back_char      (<a class="code hl_enumvalue" href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487ba0acb2dfdabf90aa922d41e5d70ac4813">hffix::tag::Side</a>, <span class="charliteral">&#39;1&#39;</span>);</div>
<div class="line">    new_order.push_back_timestamp (<a class="code hl_enumvalue" href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487bae033cb2d8758e7b20af1415f67d2deef">hffix::tag::TransactTime</a>, tsend);</div>
<div class="line">    <span class="comment">// 100 shares.</span></div>
<div class="line">    new_order.push_back_int       (<a class="code hl_enumvalue" href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487ba73138cea94a1dc16e6cee3854f32ddb5">hffix::tag::OrderQty</a>, 100);</div>
<div class="line">    <span class="comment">// Limit order.</span></div>
<div class="line">    new_order.push_back_char      (<a class="code hl_enumvalue" href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487ba1f7ef1988658c02b8640be901a611dde">hffix::tag::OrdType</a>, <span class="charliteral">&#39;2&#39;</span>);</div>
<div class="line">    <span class="comment">// Limit price $500.01 = 50001*(10^-2). The push_back_decimal() method</span></div>
<div class="line">    <span class="comment">// takes a decimal floating point number of the form mantissa*(10^exponent).</span></div>
<div class="line">    new_order.push_back_decimal   (<a class="code hl_enumvalue" href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487baeaa17c723b95fa37d0b3794ac0a16bbc">hffix::tag::Price</a>, 50001, -2);</div>
<div class="line">    <span class="comment">// Good Till Cancel.</span></div>
<div class="line">    new_order.push_back_char      (<a class="code hl_enumvalue" href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487bab6dc6fd3f14238cfa318dc244ca296ab">hffix::tag::TimeInForce</a>, <span class="charliteral">&#39;1&#39;</span>);</div>
<div class="line"> </div>
<div class="line">    new_order.push_back_trailer(); <span class="comment">// write CheckSum.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">//Now the New Order message is in the buffer after the Logon message.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Write both messages to stdout.</span></div>
<div class="line">    std::cout.write(buffer, new_order.message_end() - buffer);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclasshffix_1_1message__writer_html"><div class="ttname"><a href="classhffix_1_1message__writer.html">hffix::message_writer</a></div><div class="ttdoc">One FIX message for writing.</div><div class="ttdef"><b>Definition</b> <a href="hffix_8hpp_source.html#l00622">hffix.hpp:622</a></div></div>
<div class="ttc" id="ahffix_8hpp_html"><div class="ttname"><a href="hffix_8hpp.html">hffix.hpp</a></div><div class="ttdoc">The High Frequency FIX Parser Library. Repository at http://github.com/jamesdbrock/hffix.</div></div>
<div class="ttc" id="anamespacehffix_1_1tag_html_a66ea8cc10760e55c6f323a7edfe3487ba0acb2dfdabf90aa922d41e5d70ac4813"><div class="ttname"><a href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487ba0acb2dfdabf90aa922d41e5d70ac4813">hffix::tag::Side</a></div><div class="ttdeci">@ Side</div><div class="ttdef"><b>Definition</b> <a href="hffix__fields_8hpp_source.html#l00127">hffix_fields.hpp:127</a></div></div>
<div class="ttc" id="anamespacehffix_1_1tag_html_a66ea8cc10760e55c6f323a7edfe3487ba0cd1257dc61dfa06ed979993350a727c"><div class="ttname"><a href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487ba0cd1257dc61dfa06ed979993350a727c">hffix::tag::HandlInst</a></div><div class="ttdeci">@ HandlInst</div><div class="ttdef"><b>Definition</b> <a href="hffix__fields_8hpp_source.html#l00080">hffix_fields.hpp:80</a></div></div>
<div class="ttc" id="anamespacehffix_1_1tag_html_a66ea8cc10760e55c6f323a7edfe3487ba1c04775c30e6fc84f399536e376e17db"><div class="ttname"><a href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487ba1c04775c30e6fc84f399536e376e17db">hffix::tag::HeartBtInt</a></div><div class="ttdeci">@ HeartBtInt</div><div class="ttdef"><b>Definition</b> <a href="hffix__fields_8hpp_source.html#l00220">hffix_fields.hpp:220</a></div></div>
<div class="ttc" id="anamespacehffix_1_1tag_html_a66ea8cc10760e55c6f323a7edfe3487ba1f7ef1988658c02b8640be901a611dde"><div class="ttname"><a href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487ba1f7ef1988658c02b8640be901a611dde">hffix::tag::OrdType</a></div><div class="ttdeci">@ OrdType</div><div class="ttdef"><b>Definition</b> <a href="hffix__fields_8hpp_source.html#l00114">hffix_fields.hpp:114</a></div></div>
<div class="ttc" id="anamespacehffix_1_1tag_html_a66ea8cc10760e55c6f323a7edfe3487ba4077088f5a179648e4bf53281329b932"><div class="ttname"><a href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487ba4077088f5a179648e4bf53281329b932">hffix::tag::Symbol</a></div><div class="ttdeci">@ Symbol</div><div class="ttdef"><b>Definition</b> <a href="hffix__fields_8hpp_source.html#l00130">hffix_fields.hpp:128</a></div></div>
<div class="ttc" id="anamespacehffix_1_1tag_html_a66ea8cc10760e55c6f323a7edfe3487ba73138cea94a1dc16e6cee3854f32ddb5"><div class="ttname"><a href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487ba73138cea94a1dc16e6cee3854f32ddb5">hffix::tag::OrderQty</a></div><div class="ttdeci">@ OrderQty</div><div class="ttdef"><b>Definition</b> <a href="hffix__fields_8hpp_source.html#l00112">hffix_fields.hpp:110</a></div></div>
<div class="ttc" id="anamespacehffix_1_1tag_html_a66ea8cc10760e55c6f323a7edfe3487ba873332fa303a3d02d2201337806aede7"><div class="ttname"><a href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487ba873332fa303a3d02d2201337806aede7">hffix::tag::ClOrdID</a></div><div class="ttdeci">@ ClOrdID</div><div class="ttdef"><b>Definition</b> <a href="hffix__fields_8hpp_source.html#l00048">hffix_fields.hpp:48</a></div></div>
<div class="ttc" id="anamespacehffix_1_1tag_html_a66ea8cc10760e55c6f323a7edfe3487ba90e2170482ce314ceef2d58ccc6d0638"><div class="ttname"><a href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487ba90e2170482ce314ceef2d58ccc6d0638">hffix::tag::SendingTime</a></div><div class="ttdeci">@ SendingTime</div><div class="ttdef"><b>Definition</b> <a href="hffix__fields_8hpp_source.html#l00123">hffix_fields.hpp:123</a></div></div>
<div class="ttc" id="anamespacehffix_1_1tag_html_a66ea8cc10760e55c6f323a7edfe3487baa745e1759f1ef78abff6585521b21159"><div class="ttname"><a href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487baa745e1759f1ef78abff6585521b21159">hffix::tag::SenderCompID</a></div><div class="ttdeci">@ SenderCompID</div><div class="ttdef"><b>Definition</b> <a href="hffix__fields_8hpp_source.html#l00121">hffix_fields.hpp:121</a></div></div>
<div class="ttc" id="anamespacehffix_1_1tag_html_a66ea8cc10760e55c6f323a7edfe3487baaefd2f2a07aa3496587f459d8a3d024b"><div class="ttname"><a href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487baaefd2f2a07aa3496587f459d8a3d024b">hffix::tag::EncryptMethod</a></div><div class="ttdeci">@ EncryptMethod</div><div class="ttdef"><b>Definition</b> <a href="hffix__fields_8hpp_source.html#l00206">hffix_fields.hpp:206</a></div></div>
<div class="ttc" id="anamespacehffix_1_1tag_html_a66ea8cc10760e55c6f323a7edfe3487baaf9503fa60ec34d2bafd7444eff6c42c"><div class="ttname"><a href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487baaf9503fa60ec34d2bafd7444eff6c42c">hffix::tag::TargetCompID</a></div><div class="ttdeci">@ TargetCompID</div><div class="ttdef"><b>Definition</b> <a href="hffix__fields_8hpp_source.html#l00131">hffix_fields.hpp:131</a></div></div>
<div class="ttc" id="anamespacehffix_1_1tag_html_a66ea8cc10760e55c6f323a7edfe3487bab32e2b61a6da369187ba759ef12e1fa3"><div class="ttname"><a href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487bab32e2b61a6da369187ba759ef12e1fa3">hffix::tag::MsgSeqNum</a></div><div class="ttdeci">@ MsgSeqNum</div><div class="ttdef"><b>Definition</b> <a href="hffix__fields_8hpp_source.html#l00102">hffix_fields.hpp:102</a></div></div>
<div class="ttc" id="anamespacehffix_1_1tag_html_a66ea8cc10760e55c6f323a7edfe3487bab6dc6fd3f14238cfa318dc244ca296ab"><div class="ttname"><a href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487bab6dc6fd3f14238cfa318dc244ca296ab">hffix::tag::TimeInForce</a></div><div class="ttdeci">@ TimeInForce</div><div class="ttdef"><b>Definition</b> <a href="hffix__fields_8hpp_source.html#l00136">hffix_fields.hpp:136</a></div></div>
<div class="ttc" id="anamespacehffix_1_1tag_html_a66ea8cc10760e55c6f323a7edfe3487bae033cb2d8758e7b20af1415f67d2deef"><div class="ttname"><a href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487bae033cb2d8758e7b20af1415f67d2deef">hffix::tag::TransactTime</a></div><div class="ttdeci">@ TransactTime</div><div class="ttdef"><b>Definition</b> <a href="hffix__fields_8hpp_source.html#l00137">hffix_fields.hpp:137</a></div></div>
<div class="ttc" id="anamespacehffix_1_1tag_html_a66ea8cc10760e55c6f323a7edfe3487baeaa17c723b95fa37d0b3794ac0a16bbc"><div class="ttname"><a href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487baeaa17c723b95fa37d0b3794ac0a16bbc">hffix::tag::Price</a></div><div class="ttdeci">@ Price</div><div class="ttdef"><b>Definition</b> <a href="hffix__fields_8hpp_source.html#l00118">hffix_fields.hpp:118</a></div></div>
<div class="ttc" id="anamespacehffix_1_1tag_html_a66ea8cc10760e55c6f323a7edfe3487baf0f67608ee9620fe6cd6ebeba4033922"><div class="ttname"><a href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487baf0f67608ee9620fe6cd6ebeba4033922">hffix::tag::MsgType</a></div><div class="ttdeci">@ MsgType</div><div class="ttdef"><b>Definition</b> <a href="hffix__fields_8hpp_source.html#l00107">hffix_fields.hpp:103</a></div></div>
</div><!-- fragment --><h2>Reading a Message Example</h2>
<p>This example program is in the <em>hffix</em> repository at <code>test/src/reader01.cpp</code>.</p>
<p>It reads messages from <code>stdin</code>. If it finds a <em>Logon</em> message or a <em>New Order - Single</em> message, then it prints out some information about their fields.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cstdio&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// We want Boost Date_Time support, so include these before hffix.hpp.</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/date_time/posix_time/posix_time.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/date_time/gregorian/gregorian.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="hffix_8hpp.html">hffix.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">size_t</span> chunksize = 4096; <span class="comment">// Choose a preferred I/O chunk size.</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">char</span> buffer[1 &lt;&lt; 20]; <span class="comment">// Must be larger than the largest FIX message size.</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> return_code = 0;</div>
<div class="line"> </div>
<div class="line">    std::map&lt;int, std::string&gt; field_dictionary;</div>
<div class="line">    <a class="code hl_function" href="namespacehffix.html#a7a9146dc05a357c892cb03ee878463aa">hffix::dictionary_init_field</a>(field_dictionary);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">size_t</span> buffer_length(0); <span class="comment">// The number of bytes read in buffer[].</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">size_t</span> fred; <span class="comment">// Number of bytes read from fread().</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Read chunks from stdin until 0 is read or the buffer fills up without</span></div>
<div class="line">    <span class="comment">// finding a complete message.</span></div>
<div class="line">    <span class="keywordflow">while</span> ((fred = std::fread(</div>
<div class="line">                    buffer + buffer_length,</div>
<div class="line">                    1,</div>
<div class="line">                    std::min(<span class="keyword">sizeof</span>(buffer) - buffer_length, chunksize),</div>
<div class="line">                    stdin</div>
<div class="line">                    )</div>
<div class="line">          )) {</div>
<div class="line"> </div>
<div class="line">        buffer_length += fred;</div>
<div class="line">        <a class="code hl_class" href="classhffix_1_1message__reader.html">hffix::message_reader</a> reader(buffer, buffer + buffer_length);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Try to read as many complete messages as there are in the buffer.</span></div>
<div class="line">        <span class="keywordflow">for</span> (; reader.is_complete(); reader = reader.next_message_reader()) {</div>
<div class="line">            <span class="keywordflow">if</span> (reader.is_valid()) {</div>
<div class="line"> </div>
<div class="line">                <span class="comment">// Here is a complete message. Read fields out of the reader.</span></div>
<div class="line">                <span class="keywordflow">try</span> {</div>
<div class="line">                    <span class="keywordflow">if</span> (reader.message_type()-&gt;value() == <span class="stringliteral">&quot;A&quot;</span>) {</div>
<div class="line">                        std::cout &lt;&lt; <span class="stringliteral">&quot;Logon message\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">                        <a class="code hl_class" href="classhffix_1_1message__reader__const__iterator.html">hffix::message_reader::const_iterator</a> i = reader.begin();</div>
<div class="line"> </div>
<div class="line">                        <span class="keywordflow">if</span> (reader.find_with_hint(<a class="code hl_enumvalue" href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487baa745e1759f1ef78abff6585521b21159">hffix::tag::SenderCompID</a>, i))</div>
<div class="line">                            std::cout</div>
<div class="line">                                &lt;&lt; <span class="stringliteral">&quot;SenderCompID = &quot;</span></div>
<div class="line">                                &lt;&lt; i++-&gt;<a class="code hl_function" href="classhffix_1_1field.html#a5ddefc65477dd872fb53eb231bd138ca">value</a>() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line"> </div>
<div class="line">                        <span class="keywordflow">if</span> (reader.find_with_hint(<a class="code hl_enumvalue" href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487bab32e2b61a6da369187ba759ef12e1fa3">hffix::tag::MsgSeqNum</a>, i))</div>
<div class="line">                            std::cout</div>
<div class="line">                                &lt;&lt; <span class="stringliteral">&quot;MsgSeqNum    = &quot;</span></div>
<div class="line">                                &lt;&lt; i++-&gt;<a class="code hl_function" href="classhffix_1_1field.html#a5ddefc65477dd872fb53eb231bd138ca">value</a>().<a class="code hl_function" href="classhffix_1_1field__value.html#a9c845c4553813549dc7e799879f42d2a">as_int</a>&lt;<span class="keywordtype">int</span>&gt;() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line"> </div>
<div class="line">                        <span class="keywordflow">if</span> (reader.find_with_hint(<a class="code hl_enumvalue" href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487ba90e2170482ce314ceef2d58ccc6d0638">hffix::tag::SendingTime</a>, i))</div>
<div class="line">                            std::cout</div>
<div class="line">                                &lt;&lt; <span class="stringliteral">&quot;SendingTime  = &quot;</span></div>
<div class="line">                                &lt;&lt; i++-&gt;value().as_timestamp() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line"> </div>
<div class="line">                        std::cout</div>
<div class="line">                            &lt;&lt; <span class="stringliteral">&quot;The next field is &quot;</span></div>
<div class="line">                            &lt;&lt; <a class="code hl_function" href="namespacehffix.html#a60ce8eb78305d2ecbd9c3af80e581fe7">hffix::field_name</a>(i-&gt;<a class="code hl_function" href="classhffix_1_1field.html#a3a3513cbe7fb414eac858db817a85aff">tag</a>(), field_dictionary)</div>
<div class="line">                            &lt;&lt; <span class="stringliteral">&quot; = &quot;</span> &lt;&lt; i-&gt;<a class="code hl_function" href="classhffix_1_1field.html#a5ddefc65477dd872fb53eb231bd138ca">value</a>() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line"> </div>
<div class="line">                        std::cout &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">                    }</div>
<div class="line">                    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (reader.message_type()-&gt;value() == <span class="stringliteral">&quot;D&quot;</span>) {</div>
<div class="line">                        std::cout &lt;&lt; <span class="stringliteral">&quot;New Order Single message\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">                        <a class="code hl_class" href="classhffix_1_1message__reader__const__iterator.html">hffix::message_reader::const_iterator</a> i = reader.begin();</div>
<div class="line"> </div>
<div class="line">                        <span class="keywordflow">if</span> (reader.find_with_hint(<a class="code hl_enumvalue" href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487ba0acb2dfdabf90aa922d41e5d70ac4813">hffix::tag::Side</a>, i))</div>
<div class="line">                            std::cout &lt;&lt;</div>
<div class="line">                                (i++-&gt;<a class="code hl_function" href="classhffix_1_1field.html#a5ddefc65477dd872fb53eb231bd138ca">value</a>().<a class="code hl_function" href="classhffix_1_1field__value.html#a5b1bde2648c8758a4db948c486d639a6">as_char</a>() == <span class="charliteral">&#39;1&#39;</span> ?<span class="stringliteral">&quot;Buy &quot;</span>:<span class="stringliteral">&quot;Sell &quot;</span>);</div>
<div class="line"> </div>
<div class="line">                        <span class="keywordflow">if</span> (reader.find_with_hint(<a class="code hl_enumvalue" href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487ba4077088f5a179648e4bf53281329b932">hffix::tag::Symbol</a>, i))</div>
<div class="line">                            std::cout &lt;&lt; i++-&gt;value() &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line"> </div>
<div class="line">                        <span class="keywordflow">if</span> (reader.find_with_hint(<a class="code hl_enumvalue" href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487ba73138cea94a1dc16e6cee3854f32ddb5">hffix::tag::OrderQty</a>, i))</div>
<div class="line">                            std::cout &lt;&lt; i++-&gt;value().as_int&lt;<span class="keywordtype">int</span>&gt;();</div>
<div class="line"> </div>
<div class="line">                        <span class="keywordflow">if</span> (reader.find_with_hint(<a class="code hl_enumvalue" href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487baeaa17c723b95fa37d0b3794ac0a16bbc">hffix::tag::Price</a>, i)) {</div>
<div class="line">                            <span class="keywordtype">int</span> mantissa, exponent;</div>
<div class="line">                            i-&gt;<a class="code hl_function" href="classhffix_1_1field.html#a5ddefc65477dd872fb53eb231bd138ca">value</a>().<a class="code hl_function" href="classhffix_1_1field__value.html#a9ab721a634c9842c171591a8fec9488d">as_decimal</a>(mantissa, exponent);</div>
<div class="line">                            std::cout &lt;&lt; <span class="stringliteral">&quot; @ $&quot;</span> &lt;&lt; mantissa &lt;&lt; <span class="stringliteral">&quot;E&quot;</span> &lt;&lt; exponent;</div>
<div class="line">                            ++i;</div>
<div class="line">                        }</div>
<div class="line"> </div>
<div class="line">                        std::cout &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line">                    }</div>
<div class="line"> </div>
<div class="line">                } <span class="keywordflow">catch</span>(std::exception&amp; ex) {</div>
<div class="line">                    std::cerr &lt;&lt; <span class="stringliteral">&quot;Error reading fields: &quot;</span> &lt;&lt; ex.what() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">                }</div>
<div class="line"> </div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                <span class="comment">// An invalid, corrupted FIX message. Do not try to read fields</span></div>
<div class="line">                <span class="comment">// out of this reader. The beginning of the invalid message is</span></div>
<div class="line">                <span class="comment">// at location reader.message_begin() in the buffer, but the</span></div>
<div class="line">                <span class="comment">// end of the invalid message is unknown (because it&#39;s invalid).</span></div>
<div class="line">                <span class="comment">//</span></div>
<div class="line">                <span class="comment">// Stay in this for loop, because the</span></div>
<div class="line">                <span class="comment">// messager_reader::next_message_reader() function will see</span></div>
<div class="line">                <span class="comment">// that this message is invalid and it will search the</span></div>
<div class="line">                <span class="comment">// remainder of the buffer for the text &quot;8=FIX&quot;, to see if</span></div>
<div class="line">                <span class="comment">// there might be a complete or partial valid message anywhere</span></div>
<div class="line">                <span class="comment">// else in the remainder of the buffer.</span></div>
<div class="line">                <span class="comment">//</span></div>
<div class="line">                <span class="comment">// Set the return code non-zero to indicate that there was</span></div>
<div class="line">                <span class="comment">// an invalid message, and print the first 64 chars of the</span></div>
<div class="line">                <span class="comment">// invalid message.</span></div>
<div class="line">                return_code = 1;</div>
<div class="line">                std::cerr &lt;&lt; <span class="stringliteral">&quot;Error Invalid FIX message: &quot;</span>;</div>
<div class="line">                std::cerr.write(</div>
<div class="line">                    reader.message_begin(),</div>
<div class="line">                    std::min(</div>
<div class="line">                        ssize_t(64),</div>
<div class="line">                        buffer + buffer_length - reader.message_begin()</div>
<div class="line">                        )</div>
<div class="line">                    );</div>
<div class="line">                std::cerr &lt;&lt; <span class="stringliteral">&quot;...\n&quot;</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        buffer_length = reader.buffer_end() - reader.buffer_begin();</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (buffer_length &gt; 0)</div>
<div class="line">            <span class="comment">// Then there is an incomplete message at the end of the buffer.</span></div>
<div class="line">            <span class="comment">// Move the partial portion of the incomplete message to buffer[0].</span></div>
<div class="line">            std::memmove(buffer, reader.buffer_begin(), buffer_length);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> return_code;</div>
<div class="line">}</div>
<div class="ttc" id="aclasshffix_1_1field__value_html_a5b1bde2648c8758a4db948c486d639a6"><div class="ttname"><a href="classhffix_1_1field__value.html#a5b1bde2648c8758a4db948c486d639a6">hffix::field_value::as_char</a></div><div class="ttdeci">char as_char() const</div><div class="ttdoc">Ascii value as char.</div><div class="ttdef"><b>Definition</b> <a href="hffix_8hpp_source.html#l01719">hffix.hpp:1719</a></div></div>
<div class="ttc" id="aclasshffix_1_1field__value_html_a9ab721a634c9842c171591a8fec9488d"><div class="ttname"><a href="classhffix_1_1field__value.html#a9ab721a634c9842c171591a8fec9488d">hffix::field_value::as_decimal</a></div><div class="ttdeci">void as_decimal(Int_type &amp;mantissa, Int_type &amp;exponent) const</div><div class="ttdoc">Ascii-to-decimal conversion.</div><div class="ttdef"><b>Definition</b> <a href="hffix_8hpp_source.html#l01741">hffix.hpp:1741</a></div></div>
<div class="ttc" id="aclasshffix_1_1field__value_html_a9c845c4553813549dc7e799879f42d2a"><div class="ttname"><a href="classhffix_1_1field__value.html#a9c845c4553813549dc7e799879f42d2a">hffix::field_value::as_int</a></div><div class="ttdeci">Int_type as_int() const</div><div class="ttdoc">Ascii-to-integer conversion.</div><div class="ttdef"><b>Definition</b> <a href="hffix_8hpp_source.html#l01778">hffix.hpp:1778</a></div></div>
<div class="ttc" id="aclasshffix_1_1field_html_a3a3513cbe7fb414eac858db817a85aff"><div class="ttname"><a href="classhffix_1_1field.html#a3a3513cbe7fb414eac858db817a85aff">hffix::field::tag</a></div><div class="ttdeci">int tag() const</div><div class="ttdoc">Tag of the field.</div><div class="ttdef"><b>Definition</b> <a href="hffix_8hpp_source.html#l02154">hffix.hpp:2154</a></div></div>
<div class="ttc" id="aclasshffix_1_1field_html_a5ddefc65477dd872fb53eb231bd138ca"><div class="ttname"><a href="classhffix_1_1field.html#a5ddefc65477dd872fb53eb231bd138ca">hffix::field::value</a></div><div class="ttdeci">field_value const &amp; value() const</div><div class="ttdoc">Weakly-typed value of the field.</div><div class="ttdef"><b>Definition</b> <a href="hffix_8hpp_source.html#l02159">hffix.hpp:2159</a></div></div>
<div class="ttc" id="aclasshffix_1_1message__reader__const__iterator_html"><div class="ttname"><a href="classhffix_1_1message__reader__const__iterator.html">hffix::message_reader_const_iterator</a></div><div class="ttdoc">The iterator type for hffix::message_reader. Typedef'd as hffix::message_reader::const_iterator.</div><div class="ttdef"><b>Definition</b> <a href="hffix_8hpp_source.html#l02181">hffix.hpp:2181</a></div></div>
<div class="ttc" id="aclasshffix_1_1message__reader_html"><div class="ttname"><a href="classhffix_1_1message__reader.html">hffix::message_reader</a></div><div class="ttdoc">One FIX message for reading.</div><div class="ttdef"><b>Definition</b> <a href="hffix_8hpp_source.html#l02396">hffix.hpp:2396</a></div></div>
<div class="ttc" id="anamespacehffix_html_a60ce8eb78305d2ecbd9c3af80e581fe7"><div class="ttname"><a href="namespacehffix.html#a60ce8eb78305d2ecbd9c3af80e581fe7">hffix::field_name</a></div><div class="ttdeci">details::field_name_streamer&lt; AssociativeContainer &gt; field_name(int tag, AssociativeContainer const &amp;field_dictionary, bool or_number=true)</div><div class="ttdoc">Given a field tag number and a field name dictionary, returns a type which provides operator&lt;&lt; to wri...</div><div class="ttdef"><b>Definition</b> <a href="hffix_8hpp_source.html#l02974">hffix.hpp:2974</a></div></div>
<div class="ttc" id="anamespacehffix_html_a7a9146dc05a357c892cb03ee878463aa"><div class="ttname"><a href="namespacehffix.html#a7a9146dc05a357c892cb03ee878463aa">hffix::dictionary_init_field</a></div><div class="ttdeci">void dictionary_init_field(AssociativeContainer &amp;dictionary)</div><div class="ttdoc">Populate an AssociativeContainer with the names of all the FIX fields.</div><div class="ttdef"><b>Definition</b> <a href="hffix__fields_8hpp_source.html#l07945">hffix_fields.hpp:7945</a></div></div>
</div><!-- fragment --><h2>Running the Examples</h2>
<p>The writer example can be piped to the reader example. Running these commands: </p><pre class="fragment">make examples
test/bin/writer01 | test/bin/reader01
</pre><p> Should produce output like this:</p>
<pre style="white-space:pre-wrap;background-color:#171717;padding:1em;">
<span style="color: #F5F1DE">Logon message
SenderCompID = AAAA
MsgSeqNum =    1
SendingTime =  2014-Sep-26 15:27:38.789000
The next field is EncryptMethod = 0<br  />

New Order Single message
Buy OIH 100 @ $50001E-2
</span>
</pre><p>To examine the output from <code>test/bin/writer01</code> program, you can also use <code>util/bin/fixprint</code>, like this: </p><pre class="fragment">make examples
make fixprint
test/bin/writer01 | util/bin/fixprint --color
</pre><p> Which will produce output like this:</p>
<pre style="white-space:pre-wrap;background-color:#171717;padding:1em;">
<span style="color: #F5F1DE">FIX.4.2 </span><span style="color: #aa5500">MsgType_35=</span><span style="color: #aa0000">A_Logon </span><span style="color: #aa5500">SenderCompID_49=</span><span style="color: #F5F1DE">AAAA </span><span style="color: #aa5500">TargetCompID_56=</span><span style="color: #F5F1DE">BBBB </span><span style="color: #aa5500">MsgSeqNum_34=</span><span style="color: #F5F1DE">1 </span><span style="color: #aa5500">SendingTime_52=</span><span style="color: #F5F1DE">20140928-07:12:06.000 </span><span style="color: #aa5500">EncryptMethod_98=</span><span style="color: #F5F1DE">0 </span><span style="color: #aa5500">HeartBtInt_108=</span><span style="color: #F5F1DE">10</span>
<span style="color: #F5F1DE">FIX.4.2 </span><span style="color: #aa5500">MsgType_35=</span><span style="color: #aa0000">D_NewOrderSingle </span><span style="color: #aa5500">SenderCompID_49=</span><span style="color: #F5F1DE">AAAA </span><span style="color: #aa5500">TargetCompID_56=</span><span style="color: #F5F1DE">BBBB </span><span style="color: #aa5500">MsgSeqNum_34=</span><span style="color: #F5F1DE">2 </span><span style="color: #aa5500">SendingTime_52=</span><span style="color: #F5F1DE">20140928-07:12:06.000 </span><span style="color: #aa5500">ClOrdID_11=</span><span style="color: #F5F1DE">A1 </span><span style="color: #aa5500">HandlInst_21=</span><span style="color: #F5F1DE">1 </span><span style="color: #aa5500">Symbol_55=</span><span style="color: #F5F1DE">OIH </span><span style="color: #aa5500">Side_54=</span><span style="color: #F5F1DE">1 </span><span style="color: #aa5500">TransactTime_60=</span><span style="color: #F5F1DE">20140928-07:12:06.000 </span><span style="color: #aa5500">OrderQty_38=</span><span style="color: #F5F1DE">100 </span><span style="color: #aa5500">OrdType_40=</span><span style="color: #F5F1DE">2 </span><span style="color: #aa5500">Price_44=</span><span style="color: #F5F1DE">500.01 </span><span style="color: #aa5500">TimeInForce_59=</span><span style="color: #F5F1DE">1</span>
</pre><h1>Dates and Times Type Support</h1>
<h2>Boost Date_Time</h2>
<p>If the <a href="http://www.boost.org/doc/html/date_time.html">Boost Date_Time</a> library is available in your build environment, <code>boost::posix_time::ptime</code>, <code>boost::posix_time::time_duration</code>, and <code>boost::gregorian::date</code> will be automatically supported for the various FIX date and time field types. See <code><a class="el" href="classhffix_1_1message__writer.html" title="One FIX message for writing.">hffix::message_writer</a></code> and <code><a class="el" href="classhffix_1_1field__value.html" title="FIX field value for hffix::message_reader.">hffix::field_value</a></code> documentation for details.</p>
<p>To enable High Frequency FIX Parser support for the Boost Date_Time library types, include the Boost libraries before the <a class="el" href="hffix_8hpp.html" title="The High Frequency FIX Parser Library. Repository at http://github.com/jamesdbrock/hffix.">hffix.hpp</a> library, like this:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;boost/date_time/posix_time/posix_time_types.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/date_time/gregorian/gregorian_types.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="hffix_8hpp.html">hffix.hpp</a>&gt;</span></div>
</div><!-- fragment --><p>To prevent High Frequency FIX Parser support for the Boost Date_Time library, <code>#define HFFIX_NO_BOOST_DATETIME</code> before including <code><a class="el" href="hffix_8hpp.html" title="The High Frequency FIX Parser Library. Repository at http://github.com/jamesdbrock/hffix.">hffix.hpp</a></code>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define HFFIX_NO_BOOST_DATETIME</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="hffix_8hpp.html">hffix.hpp</a>&gt;</span></div>
</div><!-- fragment --><h2><code>std::chrono</code></h2>
<p>If you are building under C++11 or higher then the <code>std::chrono::time_point</code> and <code>std::chrono::duration</code> types are supported for the various FIX date and time field types. See <code><a class="el" href="classhffix_1_1message__writer.html" title="One FIX message for writing.">hffix::message_writer</a></code> and <code><a class="el" href="classhffix_1_1field__value.html" title="FIX field value for hffix::message_reader.">hffix::field_value</a></code> documentation for details.</p>
<h1>Test</h1>
<p>Sample data sources, discovered by Googling.</p>
<ul>
<li><code>test/data/fix.4.1.set.1</code> <a href="http://fixparser.targetcompid.com/">http://fixparser.targetcompid.com/</a></li>
<li><code>test/data/fix.5.0.set.1</code> <a href="https://www.jse.co.za/content/JSETechnologyDocumentItems/03.%20JSE%20Indices.recv.log.txt">https://www.jse.co.za/content/JSETechnologyDocumentItems/03.%20JSE%20Indices.recv.log.txt</a></li>
<li><code>test/data/fix.5.0.set.2</code> <a href="http://blablastreet.com/workshop/TestSocketServer/TestSocketServer/bin/Debug/store/FIXT.1.1-ATP1CMEMY-OMSCMEMY.body">http://blablastreet.com/workshop/TestSocketServer/TestSocketServer/bin/Debug/store/FIXT.1.1-ATP1CMEMY-OMSCMEMY.body</a></li>
</ul>
<p>The Chicago Mercantile Exchange is also a good source of sample data files, but the files are too big to include in this repository. The script <code>test/curl.cme.data.sh</code> shows how to download them. Run <code>curl.cme.data.sh</code> in the <code>test/</code> directory.</p>
<h1>Cookbook</h1>
<h2>Multi-threaded Sending</h2>
<p>Q: I have a bunch of different threads serializing and sending FIX messages out one socket. When each message is sent it needs a <em>MsgSeqNum</em>, but at serialization time I don't know what the <em>MsgSeqNum</em> will be, I only know that at sending time.</p>
<p>A: That multi-threading model is not a good choice for your software. The performance penalty for that threading model is much greater than the performance advantage of this non-allocating parser library. You should consider redesigning to use a single-threaded simultaneous-wait event loop like <em>libev</em> or <em>Boost Asio</em>. If you insist on multi-threading, then you could do something like this code example.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classhffix_1_1message__writer.html">hffix::message_writer</a> m;</div>
<div class="line">m.<a class="code hl_function" href="classhffix_1_1message__writer.html#ad30c446f09b05757b8ed94e3c1e42f51">push_back_string</a>(<a class="code hl_enumvalue" href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487bab32e2b61a6da369187ba759ef12e1fa3">hffix::tag::MsgSeqNum</a>, <span class="stringliteral">&quot;00000000&quot;</span>); <span class="comment">// Make a placeholder value over which you can later paste your sequence number.</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// This thread_safe_send() function will correctly sequence FIX messages if two threads are racing to call thread_safe_send().</span></div>
<div class="line"><span class="keywordtype">void</span> thread_safe_send(<a class="code hl_class" href="classhffix_1_1message__writer.html">hffix::message_writer</a> <span class="keyword">const</span>&amp; w) {</div>
<div class="line">  lock l(send_mutex_); <span class="comment">// Serialize access to this function.</span></div>
<div class="line">  <a class="code hl_class" href="classhffix_1_1message__reader.html">hffix::message_reader</a> r(w); <span class="comment">// Construct a reader from the writer.</span></div>
<div class="line">  <a class="code hl_class" href="classhffix_1_1message__reader__const__iterator.html">hffix::message_reader::const_iterator</a> i = std::find_if(r.begin(), r.end(), <a class="code hl_struct" href="structhffix_1_1tag__equal.html">hffix::tag_equal</a>(<a class="code hl_enumvalue" href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487bab32e2b61a6da369187ba759ef12e1fa3">hffix::tag::MsgSeqNum</a>)); <span class="comment">// Find the MsgSeqNum field.</span></div>
<div class="line">  <span class="keywordflow">if</span> (i != r.end()) {</div>
<div class="line">    std::snprintf(<span class="keyword">const_cast&lt;</span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(i-&gt;<a class="code hl_function" href="classhffix_1_1field.html#a5ddefc65477dd872fb53eb231bd138ca">value</a>().<a class="code hl_function" href="classhffix_1_1field__value.html#a0a15bcbc25c37860fa891f10bdd72c24">begin</a>()), i-&gt;<a class="code hl_function" href="classhffix_1_1field.html#a5ddefc65477dd872fb53eb231bd138ca">value</a>().<a class="code hl_function" href="classhffix_1_1field__value.html#aa795b19b61c4a1edc5627bff5f08a802">size</a>(), <span class="stringliteral">&quot;%.8i&quot;</span>, next_sequence_number++); <span class="comment">// Overwrite the &quot;00000000&quot; string with the next_sequence_number.</span></div>
<div class="line">    write(fd, w.<a class="code hl_function" href="classhffix_1_1message__writer.html#addffb68c03c46517569808529ecc2c5a">message_begin</a>(), w.<a class="code hl_function" href="classhffix_1_1message__writer.html#af6eee2cbc43e54774f00bd8e5a2d22cc">message_size</a>()); <span class="comment">// Send the message to the socket.</span></div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="aclasshffix_1_1field__value_html_a0a15bcbc25c37860fa891f10bdd72c24"><div class="ttname"><a href="classhffix_1_1field__value.html#a0a15bcbc25c37860fa891f10bdd72c24">hffix::field_value::begin</a></div><div class="ttdeci">char const * begin() const</div><div class="ttdoc">Pointer to the beginning of the field value in the buffer.</div><div class="ttdef"><b>Definition</b> <a href="hffix_8hpp_source.html#l01579">hffix.hpp:1579</a></div></div>
<div class="ttc" id="aclasshffix_1_1field__value_html_aa795b19b61c4a1edc5627bff5f08a802"><div class="ttname"><a href="classhffix_1_1field__value.html#aa795b19b61c4a1edc5627bff5f08a802">hffix::field_value::size</a></div><div class="ttdeci">size_t size() const</div><div class="ttdoc">Size of the field value, in bytes.</div><div class="ttdef"><b>Definition</b> <a href="hffix_8hpp_source.html#l01589">hffix.hpp:1589</a></div></div>
<div class="ttc" id="aclasshffix_1_1message__writer_html_ad30c446f09b05757b8ed94e3c1e42f51"><div class="ttname"><a href="classhffix_1_1message__writer.html#ad30c446f09b05757b8ed94e3c1e42f51">hffix::message_writer::push_back_string</a></div><div class="ttdeci">void push_back_string(int tag, char const *begin, char const *end)</div><div class="ttdoc">Append a string field to the message.</div><div class="ttdef"><b>Definition</b> <a href="hffix_8hpp_source.html#l00848">hffix.hpp:848</a></div></div>
<div class="ttc" id="aclasshffix_1_1message__writer_html_addffb68c03c46517569808529ecc2c5a"><div class="ttname"><a href="classhffix_1_1message__writer.html#addffb68c03c46517569808529ecc2c5a">hffix::message_writer::message_begin</a></div><div class="ttdeci">char * message_begin() const</div><div class="ttdoc">Pointer to beginning of the message.</div><div class="ttdef"><b>Definition</b> <a href="hffix_8hpp_source.html#l00685">hffix.hpp:685</a></div></div>
<div class="ttc" id="aclasshffix_1_1message__writer_html_af6eee2cbc43e54774f00bd8e5a2d22cc"><div class="ttname"><a href="classhffix_1_1message__writer.html#af6eee2cbc43e54774f00bd8e5a2d22cc">hffix::message_writer::message_size</a></div><div class="ttdeci">size_t message_size() const</div><div class="ttdoc">Size of the message in bytes.</div><div class="ttdef"><b>Definition</b> <a href="hffix_8hpp_source.html#l00676">hffix.hpp:676</a></div></div>
<div class="ttc" id="astructhffix_1_1tag__equal_html"><div class="ttname"><a href="structhffix_1_1tag__equal.html">hffix::tag_equal</a></div><div class="ttdoc">A predicate constructed with a FIX tag which returns true if the tag of the hffix::field passed to th...</div><div class="ttdef"><b>Definition</b> <a href="hffix_8hpp_source.html#l02305">hffix.hpp:2305</a></div></div>
</div><!-- fragment --><h2>FIX Repeating Groups</h2>
<p>From <em>FIX-50_SP2_VOL-1_w_Errata_20110818.pdf</em> page 21:</p>
<blockquote class="doxtable">
<p>If the repeating group is used, the first field of the repeating group is required. This allows implementations of the protocol to use the first field as a "delimiter" indicating a new repeating group entry. The first field listed after the NoXXX, then becomes conditionally required if the NoXXX field is greater than zero.</p>
</blockquote>
<p>The beginning of each Repeating Group is marked by a field with a “NoXXX” field. By convention, Repeating Groups are usually located at the end of the message, so the end of the message marks the end of the Repeating Group. In this example we assume that the convention holds, and the repeating group is at the end of the message. If the repeating group were not at the end of the message then we'd have to pay attention to the value of the “NoXXX” fields, which is left as an exercise for the reader.</p>
<p>This is an example of iterating over the nested Repeating Groups when reading a <em>Mass Quote</em> message. The <em>Mass Quote</em> message has <em>QuoteSet</em> Repeating Groups, and nested inside those groups are <em>QuoteEntry</em> Repeating Groups, see <em>fix-42-with_errata_20010501.pdf</em> page 52. In each repeated <em>QuoteSet</em> Group, <code><a class="el" href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487ba603f7c4868dd12cad52521242b7ea6e4">hffix::tag::QuoteSetID</a></code> is always the first field. In each repeated <em>QuoteEntry</em> Group, <code><a class="el" href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487ba0c106ca14776e6a1eb58e442c99d49ec">hffix::tag::QuoteEntryID</a></code> is always the first field.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classhffix_1_1message__reader.html">hffix::message_reader</a> r;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classhffix_1_1message__reader__const__iterator.html">hffix::message_reader::const_iterator</a> group1_begin = std::find_if(r.<a class="code hl_function" href="classhffix_1_1message__reader.html#ae993c80df6d7ab4ac3fdd838471777c0">begin</a>(), r.<a class="code hl_function" href="classhffix_1_1message__reader.html#a766234db0fadea164a1e4f71f49af381">end</a>(), <a class="code hl_struct" href="structhffix_1_1tag__equal.html">hffix::tag_equal</a>(<a class="code hl_enumvalue" href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487ba603f7c4868dd12cad52521242b7ea6e4">hffix::tag::QuoteSetID</a>));</div>
<div class="line"><a class="code hl_class" href="classhffix_1_1message__reader__const__iterator.html">hffix::message_reader::const_iterator</a> group1_end;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (; group1_begin != r.<a class="code hl_function" href="classhffix_1_1message__reader.html#a766234db0fadea164a1e4f71f49af381">end</a>(); group1_begin = group1_end) {</div>
<div class="line">    group1_end = std::find_if(group1_begin + 1, r.<a class="code hl_function" href="classhffix_1_1message__reader.html#a766234db0fadea164a1e4f71f49af381">end</a>(), <a class="code hl_struct" href="structhffix_1_1tag__equal.html">hffix::tag_equal</a>(<a class="code hl_enumvalue" href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487ba603f7c4868dd12cad52521242b7ea6e4">hffix::tag::QuoteSetID</a>));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// This loop body will be entered once for each QuoteSet Repeating Group.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// group1_begin will point to the first field in the QuoteSet group, which is always hffix::tag::QuoteSetID.</span></div>
<div class="line">    <span class="comment">// group1_end   will point past-the-end of the QuoteSet group.</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classhffix_1_1message__reader__const__iterator.html">hffix::message_reader::const_iterator</a> group2_begin = std::find_if(group1_begin, group1_end, <a class="code hl_struct" href="structhffix_1_1tag__equal.html">hffix::tag_equal</a>(<a class="code hl_enumvalue" href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487ba0c106ca14776e6a1eb58e442c99d49ec">hffix::tag::QuoteEntryID</a>));</div>
<div class="line">    <a class="code hl_class" href="classhffix_1_1message__reader__const__iterator.html">hffix::message_reader::const_iterator</a> group2_end;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (; group2_begin != group1_end; group2_begin = group2_end) {</div>
<div class="line">        group2_end = std::find_if(group2_begin + 1, group1_end, <a class="code hl_struct" href="structhffix_1_1tag__equal.html">hffix::tag_equal</a>(<a class="code hl_enumvalue" href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487ba0c106ca14776e6a1eb58e442c99d49ec">hffix::tag::QuoteEntryID</a>));</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// This loop body will be entered once for each QuoteEntry Repeating Group.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// group2_begin will point to the first field of the QuoteEntry group, which is always QuoteEntryID.</span></div>
<div class="line">        <span class="comment">// group2_end   will point past-the-end of the QuoteEntry group.</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclasshffix_1_1message__reader_html_a766234db0fadea164a1e4f71f49af381"><div class="ttname"><a href="classhffix_1_1message__reader.html#a766234db0fadea164a1e4f71f49af381">hffix::message_reader::end</a></div><div class="ttdeci">const_iterator end() const</div><div class="ttdoc">An iterator to the CheckSum field in the FIX message. Same as hffix::message_reader::check_sum().</div><div class="ttdef"><b>Definition</b> <a href="hffix_8hpp_source.html#l02603">hffix.hpp:2603</a></div></div>
<div class="ttc" id="aclasshffix_1_1message__reader_html_ae993c80df6d7ab4ac3fdd838471777c0"><div class="ttname"><a href="classhffix_1_1message__reader.html#ae993c80df6d7ab4ac3fdd838471777c0">hffix::message_reader::begin</a></div><div class="ttdeci">const_iterator begin() const</div><div class="ttdoc">An iterator to the MsgType field in the FIX message. Same as hffix::message_reader::message_type().</div><div class="ttdef"><b>Definition</b> <a href="hffix_8hpp_source.html#l02593">hffix.hpp:2593</a></div></div>
<div class="ttc" id="anamespacehffix_1_1tag_html_a66ea8cc10760e55c6f323a7edfe3487ba0c106ca14776e6a1eb58e442c99d49ec"><div class="ttname"><a href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487ba0c106ca14776e6a1eb58e442c99d49ec">hffix::tag::QuoteEntryID</a></div><div class="ttdeci">@ QuoteEntryID</div><div class="ttdef"><b>Definition</b> <a href="hffix__fields_8hpp_source.html#l00655">hffix_fields.hpp:655</a></div></div>
<div class="ttc" id="anamespacehffix_1_1tag_html_a66ea8cc10760e55c6f323a7edfe3487ba603f7c4868dd12cad52521242b7ea6e4"><div class="ttname"><a href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487ba603f7c4868dd12cad52521242b7ea6e4">hffix::tag::QuoteSetID</a></div><div class="ttdeci">@ QuoteSetID</div><div class="ttdef"><b>Definition</b> <a href="hffix__fields_8hpp_source.html#l00658">hffix_fields.hpp:658</a></div></div>
</div><!-- fragment --><h1>Support</h1>
<p>Please make an issue on this repository if you have any questions about how the library works or suggestions about how to improve it. If you want to talk privately then email me at <a href="#" onclick="location.href='mai'+'lto:'+'jam'+'es'+'bro'+'ck'+'@gm'+'ai'+'l.c'+'om'; return false;">james<span class="obfuscator">.nosp@m.</span>broc<span class="obfuscator">.nosp@m.</span>k@gma<span class="obfuscator">.nosp@m.</span>il.c<span class="obfuscator">.nosp@m.</span>om</a>.</p>
<h1>Contributing</h1>
<h2>Makefile</h2>
<p>Our build system is <code>make</code>. The <code>Makefile</code> provides targets and pseudo-targets for various parts of the library.</p>
<p><code>make test</code> to run the test suite.</p>
<p><code>make doc</code> to build the documentation.</p>
<h2>Nix</h2>
<p>We have a <code>flake.nix</code>.</p>
<div class="fragment"><div class="line">nix flake show github:jamesdbrock/hffix</div>
</div><!-- fragment --><h3>Development</h3>
<p>The <code>flake.nix</code> declares a <em>Nix</em> shell development environment which provides all dependencies for every target in the <code>Makefile</code>, including <em>Doxygen</em>. Enter the <em>Nix</em> shell by <a href="https://nixos.org/download.html">installing <em>Nix</em></a> and then running <code>nix develop</code> in this directory. From the <code>nix develop</code> prompt, you will be able to build all <code>Makefile</code> targets.</p>
<h3>Package</h3>
<p>The <em>Nix</em> <code>hffix</code> package will provide the <code>hffix</code> C++ library.</p>
<h3>Apps</h3>
<p>Run the <code>fixprint</code> utility:</p>
<div class="fragment"><div class="line">nix run github:jamesdbrock/hffix#fixprint</div>
</div><!-- fragment --><h2>Pull Requests</h2>
<p>Pull requests welcome!</p>
<p>If you want to submit a bugfix pull request, then I would be grateful if you would break the pull request up into two commits:</p>
<ol type="1">
<li>A commit that adds a test which fails because of the bug.</li>
<li>A commit that fixes the bug and causes the new test to pass.</li>
</ol>
<h1>Notes on the Design of FIX Protocol</h1>
<h2>The <em>Logon</em> - <em>Resend Request</em> Race Condition</h2>
<p>When a FIX client connects to a FIX server, the client doesn't know what sequence number to use for the <em>Logon</em> message.</p>
<p>Either the client can choose to reset both sequence numbers, in which case the client may miss messages, or not, in which case the client is subject to the <em>Resend Request</em> race condition.</p>
<p>After <em>Logon</em> response from the server, the client may begin sending messages, but the client has to wait some amount of time because the server may send <em>Resend Request</em>. If the client sends any message to the server while the server is preparing to send <em>Resend Request</em>, then the server's response is not defined by the <em>FIX</em> specification, and some servers implementations may seize up in confusion at that point.</p>
<h1>C++03|11|14|17|20</h1>
<p>This library only depends on C++98.</p>
<p>The library was designed with the intention of interacting well with C++11 features such as, for example, <code>auto</code>, or anonymous inline functions passed as the <code>UnaryPredicate</code> to <code><a class="el" href="namespacehffix.html#a6ec2751ee79e76fcdc40af061c307342" title="An algorithm similar to std::find_if for forward-searching over a range and finding items which match...">hffix::find_with_hint</a></code>. All the classes own no resources and are optimized for pass-by-value so move semantics are mostly irrelevent.</p>
<p><code>std::chrono</code> is supported in a <code>-std=c++11</code> build environment.</p>
<p><code>std::string_view</code> is supported in a <code>-std=c++17</code> build environment.</p>
<h1>Change Log</h1>
<table class="doxtable">
<caption>Change Log</caption>
<tr>
<th>2024-04-18 </th><th>v1.4.1 </th><td><p class="starttd">Fix for <code>std::basic_string_view&lt;char&gt;::const_iterator</code> not being convertible to <code>const char *</code> in Windows (#56)  </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>2024-02-19 </th><th>v1.4.0 </th><td><p class="starttd"></p>
<p class="intertd">Add <code><a class="el" href="classhffix_1_1message__writer.html#a2051ac234e079883d444e5e88551d74f" title="Write the BeginString and BodyLength fields to the buffer.">hffix::message_writer::push_back_header()</a></code> for <code>string_view</code>, and <code><a class="el" href="classhffix_1_1field__value.html#a10c655add0f944ec14afd52499e112f7" title="Ascii value as std::string_view.">hffix::field_value::as_string_view()</a></code> by <a href="https://github.com/skuzniar">Slawomir Kuzniar @skuzniar</a> (#51)</p>
<p class="intertd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>2023-04-28 </th><th>v1.3.0 </th><td><p class="starttd"></p>
<p class="intertd">Add <code><a class="el" href="namespacehffix_1_1msg__type.html" title="Namespace for message type constant strings.">hffix::msg_type</a></code> to <code><a class="el" href="hffix__fields_8hpp.html" title="The hffix_fields.hpp file is generated by the fixspec/spec-parse-fields Haskell program from the FIX ...">hffix_fields.hpp</a></code> (#47)</p>
<p class="intertd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>2022-05-22 </th><th>v1.2.1 </th><td><p class="starttd"></p>
<p class="intertd">Bugfix: <code>MaxMessageSize</code> is not a data length field (#45)</p>
<p class="intertd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>2021-10-11 </th><th>v1.1.1 </th><td><p class="starttd"></p>
<p class="intertd">Bugfix: <code>message_reader::prefix_size()</code> return <code>size_t</code> instead of <code>ssize_t</code>.</p>
<p class="intertd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>2021-05-17 </th><th>v1.1.0 </th><td><p class="starttd"></p>
<p class="intertd">Added support for nanosecond-precision timestamps, by <a href="https://github.com/neomantra">Evan Wies @neomantra</a></p>
<p class="intertd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>2020-10-11 </th><th>v1.0.1 </th><td><p class="starttd"></p>
<p class="intertd">Changed the <code>message_reader</code> copy-assignment operator so that Address Sanitizer doesn't complain that <code>ERROR: AddressSanitizer: stack-use-after-scope</code>. By <a href="https://github.com/mvanslobbe">Michiel van Slobbe @mvanslobbe</a></p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>2020-08-15 </th><th>v1.0.0 </th><td><p class="starttd"></p>
<p class="intertd">Version 1.</p>
<p class="intertd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>2018-12-09 </th><th></th><td><p class="starttd"></p>
<p class="intertd">Added support for <code>std::chrono</code>, by <a href="https://github.com/msherman13">@msherman13</a></p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>2018-12-09 </th><th></th><td><p class="starttd"></p>
<p class="intertd">Replace parsing of all the old FIX specs with parsing of the FIX Repository <a href="https://www.fixtrading.org/standards/fix-repository/">https://www.fixtrading.org/standards/fix-repository/</a> to generate <code><a class="el" href="hffix__fields_8hpp.html" title="The hffix_fields.hpp file is generated by the fixspec/spec-parse-fields Haskell program from the FIX ...">hffix_fields.hpp</a></code>.</p>
<p class="intertd">This results in a lot more <code>length_fields</code> in <code><a class="el" href="hffix__fields_8hpp.html" title="The hffix_fields.hpp file is generated by the fixspec/spec-parse-fields Haskell program from the FIX ...">hffix_fields.hpp</a></code>, so change the algorithm for <code>is_tag_a_data_length()</code>.</p>
<p class="intertd">Keep all the old FIX spec documents in the repo for reference.</p>
<h3>Breaking Changes</h3>
<p class="intertd"></p>
<p class="intertd">Some field names in <code><a class="el" href="namespacehffix_1_1tag.html" title="Namespace for all field tag name enums.">hffix::tag</a></code> were from the abbreviated FIX field name because the old specs were weird and difficult to parse. Field names now come from the FIX Repository and so all of the <code><a class="el" href="namespacehffix_1_1tag.html" title="Namespace for all field tag name enums.">hffix::tag</a></code> field names have become full field names. If your code fails to compile because it can't find, for example, <code>hffix::tag::NoReltdSym</code>, then change the symbol to <code><a class="el" href="namespacehffix_1_1tag.html#a66ea8cc10760e55c6f323a7edfe3487ba6bb8e9e963c583cd454cba3b34ade0f4">hffix::tag::NoRelatedSym</a></code>.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>2018-10-24 </th><th></th><td><p class="starttd"></p>
<p class="intertd">Replace the Python <code>codegen</code> spec parser with a Haskell <code>spec-parse-fields</code> spec parser.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<th>2017-09-12 </th><th></th><td><p class="starttd"></p>
<p class="intertd">Added support for <code>std::string_view</code>, by <a href="https://github.com/arvidn">Arvid Norberg @arvidn</a></p>
<p class="endtd"></p>
</td></tr>
</table>
<h1>Contributors</h1>
<p>Thank you to the following contributors, who mostly don't show up in the Github <em>Contributors</em> list because of my habit of adding “cleanup” commits to other people's pull requests.</p>
<ul>
<li><a href="https://github.com/arvidn">Arvid Norberg @arvidn</a></li>
<li><a href="https://github.com/msherman13">@msherman13</a></li>
<li><a href="https://github.com/j0nnyw">@j0nnyw</a></li>
<li><a href="https://github.com/kylrth">Kyle Roth @kylrth</a></li>
<li><a href="https://github.com/aqk">Adam Kelly @aqk</a></li>
<li><a href="https://github.com/mvanslobbe">Michiel van Slobbe @mvanslobbe</a></li>
<li><a href="https://github.com/neomantra">Evan Wies @neomantra</a> </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
